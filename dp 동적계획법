/* 
10844번 쉬운 계단 수

해석: 각 자리의 0부터 9까지의 경우를 나누어 생각한다. 특정 자리의 각 경우마다 그 앞자리의 +1인수와 -1인수가 각각 가지는 경우를 합한값임을 인지한다. 단 해당 자리의 숫자가 0이나 9일경우 각각 -1과 +1의 경우는 생각할수 없으므로 각각 그 앞자리의 1이었던 경우와 8이었던 경우를 그대로 가져온다.

필요한작업: 먼저 첫번째 자리의 경우의 수를 정해준다. 그 후 자동적으로 경우의 수가 서로 합해질수 있도록 점화식을 세워준다.

주의: if 문을 작성할때 0<j<9같은 식은 통하지 않는다. j>0 && j>9처럼만 적어야 한다. 
      int 변수가 감당할수 있는 최댓값은 약 20억이므로 20억 이상의 값이 예상될경우 long long 으로 선언하도록 하자.
      일일이 1000000000과 같은 수를 여러번 사용해야 할경우 쉽게 매크로를 이용해 #define mod 1000000000 처럼 나타내자.

#include <iostream>
#define num 1000000000
using namespace std;
int main(){
    ios::sync_with_stdio(0); cin.tie(0);
    int n, i,j;
    long long a[110][11]={0};
    long long sum=0;
    cin>>n;
    for (i=1;i<=9;i++){
        a[1][i] = 1;
    }
    for(i=2;i<=n;i++){
        for(j=0;j<=9;j++){
            if (j>0 && j<9)
            a[i][j] = (a[i-1][j-1] + a[i-1][j+1])%num;
            else if (j==0) a[i][j] = a[i-1][j+1]%num;
            else if (j==9) a[i][j] = a[i-1][j-1]%num;
        }
    }
    for(i=0;i<=9;i++){
        sum += a[n][i];
    }
    cout<<sum%num;
}

















*/

